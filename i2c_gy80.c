#include "DSP28x_Project.h"     // Device Headerfile and Examples Include File

void I2CA_Init(void) {
	// Initialize I2C
	I2caRegs.I2CSAR = 0x0053;		// Slave address - EEPROM control code

	I2caRegs.I2CPSC.all = 23;		  // Prescaler - need 7-12 Mhz on module clk
	I2caRegs.I2CCLKL = 10;			// NOTE: must be non zero
	I2caRegs.I2CCLKH = 5;			// NOTE: must be non zero
	I2caRegs.I2CIER.all = 0x24;		// Enable SCD & ARDY interrupts

	I2caRegs.I2CMDR.all = 0x0020;	// Take I2C out of reset
									// Stop I2C when suspended

	I2caRegs.I2CFFTX.all = 0x6000;	// Enable FIFO mode and TXFIFO
	I2caRegs.I2CFFRX.all = 0x2040;	// Enable RXFIFO, clear RXFFINT,

	return;
}

Uint16 I2CA_WriteData(struct I2CMSG *msg) {
	Uint16 i;

	// Wait until the STP bit is cleared from any previous master communication.
	// Clearing of this bit by the module is delayed until after the SCD bit is
	// set. If this bit is not checked prior to initiating a new message, the
	// I2C could get confused.
	if (I2caRegs.I2CMDR.bit.STP == 1) {
		return I2C_STP_NOT_READY_ERROR;
	}

	// Setup slave address
	I2caRegs.I2CSAR = msg->SlaveAddress;

	// Check if bus busy
	if (I2caRegs.I2CSTR.bit.BB == 1) {
		return I2C_BUS_BUSY_ERROR;
	}

	// Setup number of bytes to send
	// MsgBuffer + Address
	I2caRegs.I2CCNT = msg->NumOfBytes + 2;

	// Setup data to send
	I2caRegs.I2CDXR = msg->MemoryHighAddr;
	I2caRegs.I2CDXR = msg->MemoryLowAddr;
// for (i=0; i<msg->NumOfBytes-2; i++)
	for (i = 0; i < msg->NumOfBytes; i++)

	{
		I2caRegs.I2CDXR = *(msg->MsgBuffer + i);
	}

	// Send start as master transmitter
	I2caRegs.I2CMDR.all = 0x6E20;
	return I2C_SUCCESS;
}

Uint16 I2CA_ReadData(struct I2CMSG *msg) {
	// Wait until the STP bit is cleared from any previous master communication.
	// Clearing of this bit by the module is delayed until after the SCD bit is
	// set. If this bit is not checked prior to initiating a new message, the
	// I2C could get confused.
	if (I2caRegs.I2CMDR.bit.STP == 1) {
		return I2C_STP_NOT_READY_ERROR;
	}

	I2caRegs.I2CSAR = msg->SlaveAddress;

	if (msg->MsgStatus == I2C_MSGSTAT_SEND_NOSTOP) {
		// Check if bus busy
		if (I2caRegs.I2CSTR.bit.BB == 1) {
			return I2C_BUS_BUSY_ERROR;
		}
		I2caRegs.I2CCNT = 2;
		I2caRegs.I2CDXR = msg->MemoryHighAddr;
		I2caRegs.I2CDXR = msg->MemoryLowAddr;
		I2caRegs.I2CMDR.all = 0x2620;		// Send data to setup EEPROM address
	} else if (msg->MsgStatus == I2C_MSGSTAT_RESTART) {
		I2caRegs.I2CCNT = msg->NumOfBytes;	// Setup how many bytes to expect
		I2caRegs.I2CMDR.all = 0x2C20;		// Send restart as master receiver
	}

	return I2C_SUCCESS;
}
